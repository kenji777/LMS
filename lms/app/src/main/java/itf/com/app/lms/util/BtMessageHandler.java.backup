package itf.com.app.lms.util;

import android.os.Handler;
import android.os.Looper;
import android.util.Log;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Map;

/**
 * 블루투스 메시지 핸들러 최적화 클래스
 * 
 * 기존 btHandler의 최적화된 버전
 * - 메시지 처리 직렬화
 * - UI 업데이트 번들화
 * - 스펙 데이터 캐시 활용
 */
public class BtMessageHandler {
    private static final String TAG = "BtMessageHandler";
    
    // 메시지 타입 상수
    public static final int MESSAGE_READ = 1;
    public static final int CONNECTING_STATUS = 2;
    
    // 메시지 프로세서
    private final BtMessageProcessor messageProcessor;
    
    // UI 업데이트 핸들러 (메인 스레드)
    private final Handler uiHandler = new Handler(Looper.getMainLooper());
    
    // UI 업데이트 번들 수집기
    private UiUpdateBundle.Builder updateBundleBuilder = null;
    
    // UI 업데이트 스케줄링 플래그
    private boolean uiUpdateScheduled = false;
    
    // UI 업데이트 지연 시간 (ms) - 여러 업데이트를 묶기 위해
    private static final long UI_UPDATE_DELAY_MS = 16; // 약 1프레임 (60fps 기준)
    
    // UI 업데이트 실행자
    public interface UiUpdateExecutor {
        void execute(UiUpdateBundle bundle);
    }
    
    private UiUpdateExecutor uiUpdateExecutor;
    
    public BtMessageHandler(BtMessageProcessor messageProcessor) {
        this.messageProcessor = messageProcessor;
        
        // 메시지 처리 리스너 설정
        messageProcessor.setMessageProcessListener(new BtMessageProcessor.MessageProcessListener() {
            @Override
            public void onMessageProcessed(BtMessageProcessor.BtMessage message, Map<String, String> specData) {
                handleProcessedMessage(message, specData);
            }
            
            @Override
            public UiUpdateBundle createUpdateBundle(BtMessageProcessor.BtMessage message, Map<String, String> specData) {
                return createUiUpdateBundle(message, specData);
            }
        });
    }
    
    /**
     * UI 업데이트 실행자 설정
     */
    public void setUiUpdateExecutor(UiUpdateExecutor executor) {
        this.uiUpdateExecutor = executor;
    }
    
    /**
     * 메시지 처리 (기존 btHandler.handleMessage() 대체)
     */
    public void handleMessage(int what, Object obj, int arg1) {
        switch (what) {
            case MESSAGE_READ:
                byte[] payload = Arrays.copyOf((byte[]) obj, arg1);
                String handlerMessage = new String(payload, StandardCharsets.UTF_8);
                
                // 메시지 파싱
                String receiveCommand = parseReceiveCommand(handlerMessage);
                String receiveCommandResponse = parseReceiveCommandResponse(handlerMessage);
                
                // 메시지 프로세서에 큐 추가
                messageProcessor.enqueueMessage(payload, handlerMessage, receiveCommand, receiveCommandResponse);
                break;
                
            case CONNECTING_STATUS:
                // 연결 상태 처리 (기존 로직 유지)
                break;
        }
    }
    
    /**
     * receiveCommand 파싱
     */
    private String parseReceiveCommand(String readMessage) {
        try {
            int stxIndex = readMessage.indexOf(Constants.CharCodes.STX);
            if (stxIndex >= 0 && readMessage.length() >= stxIndex + 7) {
                return readMessage.substring(stxIndex + 1, stxIndex + 7);
            }
        } catch (Exception e) {
            Log.e(TAG, "Error parsing receiveCommand", e);
        }
        return "";
    }
    
    /**
     * receiveCommandResponse 파싱
     */
    private String parseReceiveCommandResponse(String readMessage) {
        try {
            if (readMessage.length() >= 15) {
                return readMessage.substring(13, 15);
            }
        } catch (Exception e) {
            Log.e(TAG, "Error parsing receiveCommandResponse", e);
        }
        return "";
    }
    
    /**
     * 처리된 메시지 핸들링
     */
    private void handleProcessedMessage(BtMessageProcessor.BtMessage message, Map<String, String> specData) {
        // UI 업데이트 번들 생성
        UiUpdateBundle bundle = createUiUpdateBundle(message, specData);
        
        if (bundle != null) {
            // UI 업데이트 스케줄링 (번들화)
            scheduleUiUpdate(bundle);
        }
    }
    
    /**
     * UI 업데이트 번들 생성
     */
    private UiUpdateBundle createUiUpdateBundle(BtMessageProcessor.BtMessage message, Map<String, String> specData) {
        UiUpdateBundle.Builder builder = new UiUpdateBundle.Builder();
        
        // 스펙 데이터가 있으면 추가
        if (specData != null && !specData.isEmpty()) {
            // 필요한 UI 업데이트 정보 수집
            // (실제 구현은 ActivityModelTestProcess의 로직에 맞게 수정 필요)
        }
        
        return builder.build();
    }
    
    /**
     * UI 업데이트 스케줄링 (번들화)
     */
    private void scheduleUiUpdate(UiUpdateBundle bundle) {
        // 첫 번째 업데이트면 빌더 초기화
        if (updateBundleBuilder == null) {
            updateBundleBuilder = new UiUpdateBundle.Builder();
        }
        
        // 번들 병합 (기존 값이 있으면 유지, 새로운 값이 있으면 덮어쓰기)
        if (bundle.dialogVisible) updateBundleBuilder.setDialogVisible(true);
        if (bundle.dialogHidden) updateBundleBuilder.setDialogHidden(true);
        if (bundle.dialogColor != 0) updateBundleBuilder.setDialogColor(bundle.dialogColor);
        if (bundle.dialogMessage != null) updateBundleBuilder.setDialogMessage(bundle.dialogMessage);
        if (bundle.temperatureText != null) updateBundleBuilder.setTemperatureText(bundle.temperatureText);
        if (bundle.compWattText != null) updateBundleBuilder.setCompWattText(bundle.compWattText);
        if (bundle.heaterWattText != null) updateBundleBuilder.setHeaterWattText(bundle.heaterWattText);
        if (bundle.pumpWattText != null) updateBundleBuilder.setPumpWattText(bundle.pumpWattText);
        if (bundle.logText != null) updateBundleBuilder.setLogText(bundle.logText);
        if (bundle.updateItemCommand != null && !bundle.updateItemCommand.isEmpty()) 
            updateBundleBuilder.setUpdateItemCommand(bundle.updateItemCommand);
        if (bundle.updateItemResult != null && !bundle.updateItemResult.isEmpty()) 
            updateBundleBuilder.setUpdateItemResult(bundle.updateItemResult);
        if (bundle.updateItemCheckValue != null && !bundle.updateItemCheckValue.isEmpty()) 
            updateBundleBuilder.setUpdateItemCheckValue(bundle.updateItemCheckValue);
        if (bundle.updateItemInfo != null && !bundle.updateItemInfo.isEmpty()) 
            updateBundleBuilder.setUpdateItemInfo(bundle.updateItemInfo);
        if (bundle.updateItemNameSuffix != null && !bundle.updateItemNameSuffix.isEmpty()) 
            updateBundleBuilder.setUpdateItemNameSuffix(bundle.updateItemNameSuffix);
        if (bundle.updateListAdapter) updateBundleBuilder.setUpdateListAdapter(true);
        if (bundle.finalReceiveCommandResponse != null) 
            updateBundleBuilder.setFinalReceiveCommandResponse(bundle.finalReceiveCommandResponse);
        if (bundle.finalCalculatedResultValue != null) 
            updateBundleBuilder.setFinalCalculatedResultValue(bundle.finalCalculatedResultValue);
        if (bundle.finalReadMessage != null) 
            updateBundleBuilder.setFinalReadMessage(bundle.finalReadMessage);
        if (bundle.temperatureValueCompDiff != null) 
            updateBundleBuilder.setTemperatureValueCompDiff(bundle.temperatureValueCompDiff);
        if (bundle.resultInfo != null) updateBundleBuilder.setResultInfo(bundle.resultInfo);
        if (bundle.decTemperatureHotValue != null) 
            updateBundleBuilder.setDecTemperatureHotValue(bundle.decTemperatureHotValue);
        if (bundle.decTemperatureColdValue != null) 
            updateBundleBuilder.setDecTemperatureColdValue(bundle.decTemperatureColdValue);
        if (bundle.finalCurrentTestItem != null) 
            updateBundleBuilder.setFinalCurrentTestItem(bundle.finalCurrentTestItem);
        if (bundle.testItemIdx != 0) updateBundleBuilder.setTestItemIdx(bundle.testItemIdx);
        if (bundle.testOkCnt != 0) updateBundleBuilder.setTestOkCnt(bundle.testOkCnt);
        if (bundle.testNgCnt != 0) updateBundleBuilder.setTestNgCnt(bundle.testNgCnt);
        if (bundle.receiveCommandResponseOK != null) 
            updateBundleBuilder.setReceiveCommandResponseOK(bundle.receiveCommandResponseOK);
        if (bundle.shouldUpdateCounts) updateBundleBuilder.setShouldUpdateCounts(true);
        if (bundle.listItemAdapter != null) 
            updateBundleBuilder.setListItemAdapter(bundle.listItemAdapter);
        if (bundle.currentProcessName != null) 
            updateBundleBuilder.setCurrentProcessName(bundle.currentProcessName);
        if (bundle.receivedMessageCnt != 0) 
            updateBundleBuilder.setReceivedMessageCnt(bundle.receivedMessageCnt);
        
        // 이미 스케줄링되어 있지 않으면 스케줄링
        if (!uiUpdateScheduled) {
            uiUpdateScheduled = true;
            uiHandler.postDelayed(this::executeUiUpdate, UI_UPDATE_DELAY_MS);
        }
    }
    
    /**
     * UI 업데이트 실행
     */
    private void executeUiUpdate() {
        uiUpdateScheduled = false;
        
        if (updateBundleBuilder != null && uiUpdateExecutor != null) {
            UiUpdateBundle bundle = updateBundleBuilder.build();
            uiUpdateExecutor.execute(bundle);
            updateBundleBuilder = null; // 리셋
        }
    }
    
    /**
     * 즉시 UI 업데이트 실행 (긴급한 경우)
     */
    public void executeUiUpdateImmediately(UiUpdateBundle bundle) {
        if (uiUpdateExecutor != null) {
            uiHandler.post(() -> uiUpdateExecutor.execute(bundle));
        }
    }
    
    /**
     * 리소스 정리
     */
    public void shutdown() {
        uiHandler.removeCallbacksAndMessages(null);
        messageProcessor.shutdown();
    }
}

